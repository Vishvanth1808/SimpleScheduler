Simple Scheduler 

Me and my teammate Vyom did this project together. In the simple_scheduler.c file, he coded the struct Job part, the addedjob() function, and the signal handler section. I did the scheduleJob() function, removecomjob() function, and the jobsummary() function. The main function, we both did together. In the simpleshell.c file, vyom did the struct job part, startscheduler() function, and the submitjob() function. I did the cleanandexit() function, printing job statistics part, and terminating the simplescheduler. Vyom and I together did the main function again.  

In simple_scheduler.c, the code implements a round-robin scheduler that assigns a set time slice (TSLICE) to each job across multiple CPUs (NCPU). Each job's characteristics are defined by the job structure: pid stores the process ID, isCompleted flags job completion, and startTime, trackTime, executionTime, and waitTime track start, end, execution, and waiting times, respectively. A maximum number of jobs are stored in the jobQueue, and the total number of jobs is tracked by jobCount. Adding jobs to the queue and utilizing fork to generate a child process for each work are important functions. One such method is addJob(int executionTime). If the queue is full, it returns an error. Round-robin scheduling is implemented by scheduleJob(), which updates wait times for jobs that are still waiting while allocating a time slice to each job. After flagging completed jobs, the remaining jobs are shifted higher and jobCount is adjusted by calling removeComJob(). Signal handling is crucial; stopScheduler(int sig) manages termination and initiates the task, while handleTime(int sig) activates scheduleJob() at the end of each time slice.A complete summary including work PIDs, start and end times, and wait times is shown by the Summary() function. The main method sets up SIGALRM and SIGINT for time-slice and termination signals, initializes NCPU and TSLICE, and then loops through pause() to wait for signals.

In simpleshell.c, a Job structure stores each job's information, including pid, job name, start and end times, and a completion flag. The scheduler is started using fork to establish a child process, and its PID is assigned to schedule_pid by the startScheduler(int ncpu, int tslice) function. With NCPU and TSLICE as parameters, execlp starts the simple_scheduler inside the child process; if it fails, it raises an error. In order to process job submissions, the submitJob(const char *program, const char *arg) function forks a new child process to execute the designated program while determining whether the job limit has been met. Details like the PID, start time, and job name are recorded in jobs[ by the parent process.The cleanAndExit() function terminates the shell and provides a detailed job summary by looping over jobs[] to track wait times, then updating end times and marking jobs as completed. Prior to sending a SIGTERM signal to halt the scheduler, it shows a summary of each job that includes the name, PID, completion time, wait time, and total time. The main function starts an interactive shell loop after configuring the NCPU and TSLICE parameters and calling startScheduler to start the scheduler. When necessary, it provides feedback on proper command usage. It processes commands, invoking cleanAndExit() on exit and submitJob() on job submissions.